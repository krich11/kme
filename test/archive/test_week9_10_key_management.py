#!/usr/bin/env python3
"""
Test Week 9-10 Key Management Implementation

This test verifies that the key storage and pool management
functionality for Weeks 9-10 works correctly.
"""

import asyncio
import datetime
import os
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from app.models.etsi_models import Key, KeyRequest
from app.models.sqlalchemy_models import Key as KeyModel
from app.services.key_pool_service import KeyPoolService
from app.services.key_service import KeyService
from app.services.key_storage_service import KeyStorageService


class TestWeek910KeyManagement:
    """Test Week 9-10 key management implementation"""

    @pytest.fixture(autouse=True)
    def setup_test_environment(self):
        """Set up test environment variables"""
        # Set required environment variables for testing
        # Use a proper base64-encoded Fernet key generated by Fernet.generate_key()
        os.environ["KME_MASTER_KEY"] = "XL7Zqx08UCRzAiX5nG8f9Ld-4YpEbgosYlVd2r0rias="
        os.environ["KME_ID"] = "AAAABBBBCCCCDDDD"
        os.environ[
            "DATABASE_URL"
        ] = "postgresql+asyncpg://postgres:password@localhost:5432/kme_test_db"
        os.environ["LOG_LEVEL"] = "INFO"

    @pytest.fixture
    def mock_db_session(self):
        """Create a properly configured mock database session"""
        session = AsyncMock()

        # Configure execute method to return a proper mock result
        mock_result = MagicMock()
        mock_result.scalar_one_or_none = MagicMock()
        mock_result.scalar = MagicMock()
        mock_result.fetchone = MagicMock()

        # Create a mock scalars result for .scalars().all() operations
        mock_scalars_result = MagicMock()
        mock_scalars_result.all = MagicMock(return_value=[])
        mock_result.scalars = MagicMock(return_value=mock_scalars_result)

        session.execute = AsyncMock(return_value=mock_result)
        session.commit = AsyncMock()
        session.rollback = AsyncMock()

        return session

    @pytest.fixture
    def key_storage_service(self, mock_db_session):
        """Create key storage service instance"""
        return KeyStorageService(mock_db_session)

    @pytest.fixture
    def key_pool_service(self, mock_db_session, key_storage_service):
        """Create key pool service instance"""
        return KeyPoolService(mock_db_session, key_storage_service)

    @pytest.fixture
    def key_service(self, mock_db_session):
        """Create key service instance"""
        return KeyService(mock_db_session)

    def test_key_storage_service_initialization(self, key_storage_service):
        """Test key storage service initialization"""
        assert key_storage_service is not None
        assert key_storage_service.db_session is not None
        assert key_storage_service._fernet is not None

    def test_key_pool_service_initialization(self, key_pool_service):
        """Test key pool service initialization"""
        assert key_pool_service is not None
        assert key_pool_service.db_session is not None
        assert key_pool_service.key_storage_service is not None

    def test_key_service_initialization(self, key_service):
        """Test key service initialization"""
        assert key_service is not None
        assert key_service.db_session is not None
        assert key_service.key_storage_service is not None
        assert key_service.key_pool_service is not None

    @pytest.mark.asyncio
    async def test_key_version_info_retrieval(
        self, key_storage_service, mock_db_session
    ):
        """Test key version information retrieval"""
        # Create a proper mock row object with the expected attributes
        mock_row = MagicMock()
        mock_row.key_id = "test-key-id"
        mock_row.created_at = datetime.datetime.utcnow()
        mock_row.key_metadata = {"version": 2}

        # Configure the mock result to return the mock row
        mock_result = mock_db_session.execute.return_value
        mock_result.fetchone.return_value = mock_row

        # Test version info retrieval
        version_info = await key_storage_service.get_key_version_info("test-key-id")

        assert version_info is not None
        assert version_info["key_id"] == "test-key-id"
        assert version_info["version"] == 2
        assert "created_at" in version_info
        assert "metadata" in version_info

    @pytest.mark.asyncio
    async def test_key_version_upgrade(self, key_storage_service, mock_db_session):
        """Test key version upgrade functionality"""
        # Mock the database update result
        mock_result = mock_db_session.execute.return_value
        mock_result.rowcount = 1  # Simulate successful update

        # Test version upgrade
        success = await key_storage_service.upgrade_key_version("test-key-id", 3)

        assert success is True

    @pytest.mark.asyncio
    async def test_cleanup_statistics_retrieval(
        self, key_storage_service, mock_db_session
    ):
        """Test cleanup statistics retrieval"""
        # Mock query results with proper structure
        mock_result = mock_db_session.execute.return_value
        mock_result.fetchone.return_value = MagicMock(
            active_keys=100, consumed_keys=50, expired_keys=25, total_keys=175
        )

        # Test cleanup statistics
        stats = await key_storage_service.get_key_cleanup_statistics()

        assert stats is not None
        assert "total_keys" in stats
        assert "expired_keys" in stats
        assert "active_keys" in stats
        assert "consumed_keys" in stats
        assert "last_updated" in stats

    @pytest.mark.asyncio
    async def test_pool_health_metrics(self, key_pool_service, mock_db_session):
        """Test key pool health metrics"""
        # Mock pool configuration to return actual values
        with patch.object(key_pool_service, "_get_pool_configuration") as mock_config:
            mock_config.return_value = {
                "max_key_count": 10000,
                "min_key_threshold": 100,
                "key_generation_rate": 1000,
                "last_key_generation": datetime.datetime.utcnow(),
            }

            # Mock count methods to return actual values
            with patch.object(key_pool_service, "_count_total_keys", return_value=5000):
                with patch.object(
                    key_pool_service, "_count_active_keys", return_value=3000
                ):
                    with patch.object(
                        key_pool_service, "_count_expired_keys", return_value=100
                    ):
                        with patch.object(
                            key_pool_service, "_count_consumed_keys", return_value=1900
                        ):
                            # Mock calculation methods
                            with patch.object(
                                key_pool_service,
                                "_calculate_consumption_rate",
                                return_value=50.0,
                            ):
                                with patch.object(
                                    key_pool_service,
                                    "_calculate_generation_rate",
                                    return_value=60.0,
                                ):
                                    with patch.object(
                                        key_pool_service,
                                        "_calculate_replenishment_frequency",
                                        return_value=2.0,
                                    ):
                                        # Test health metrics
                                        metrics = (
                                            await key_pool_service.get_pool_health_metrics()
                                        )

                                        assert metrics is not None
                                        assert "health_status" in metrics
                                        assert "availability_ratio" in metrics
                                        assert "consumption_rate_per_hour" in metrics
                                        assert "generation_rate_per_hour" in metrics

    @pytest.mark.asyncio
    async def test_pool_alerting_setup(self, key_pool_service):
        """Test key pool alerting setup"""
        # Test alerting configuration
        alert_config = {
            "low_threshold": 100,
            "critical_threshold": 50,
            "alert_interval": 300,
        }

        success = await key_pool_service.setup_pool_alerting(alert_config)
        assert success is True

    @pytest.mark.asyncio
    async def test_alert_conditions_check(self, key_pool_service):
        """Test alert conditions checking"""
        # Mock current pool status
        with patch.object(key_pool_service, "get_pool_status") as mock_status:
            mock_status.return_value = {
                "active_keys": 75,
                "total_capacity": 1000,
                "last_replenishment": datetime.datetime.utcnow(),
            }

            # Test alert conditions
            alerts = await key_pool_service.check_alert_conditions()

            assert alerts is not None
            assert isinstance(alerts, list)

    @pytest.mark.asyncio
    async def test_pool_performance_optimization(self, key_pool_service):
        """Test key pool performance optimization"""
        # Mock health metrics to avoid database dependency
        with patch.object(key_pool_service, "get_pool_health_metrics") as mock_health:
            mock_health.return_value = {
                "health_status": "healthy",
                "availability_ratio": 0.8,
                "consumption_rate_per_hour": 50.0,
                "generation_rate_per_hour": 60.0,
            }

            # Test performance optimization
            optimization_result = await key_pool_service.optimize_pool_performance()

            assert optimization_result is not None
            assert "optimizations_applied" in optimization_result

    @pytest.mark.asyncio
    async def test_key_service_integration(self, key_service, mock_db_session):
        """Test key service integration"""
        # Mock key request
        key_request = KeyRequest(
            number=5, size=256, additional_slave_SAE_IDs=["SLAVE001", "SLAVE002"]
        )

        # Mock successful key generation
        with patch.object(key_service.key_generator, "generate_keys") as mock_gen:
            mock_gen.return_value = [b"test_key_data"] * 5

            # Mock key pool availability check
            with patch.object(
                key_service.key_pool_service,
                "check_key_availability",
                return_value=True,
            ):
                # Test key request processing
                result = await key_service.process_key_request(
                    slave_sae_id="SLAVE001",
                    key_request=key_request,
                    master_sae_id="MASTER001",
                )

                assert result is not None
                assert hasattr(result, "keys")
                assert len(result.keys) == 5

    @pytest.mark.asyncio
    async def test_key_retrieval_integration(self, key_service, mock_db_session):
        """Test key retrieval integration"""
        # Mock key IDs with proper UUIDs
        key_ids = [
            "550e8400-e29b-41d4-a716-446655440000",
            "550e8400-e29b-41d4-a716-446655440001",
            "550e8400-e29b-41d4-a716-446655440002",
        ]

        # Mock key retrieval
        with patch.object(
            key_service.key_storage_service, "retrieve_key"
        ) as mock_retrieve:
            mock_retrieve.return_value = Key(
                key_ID="550e8400-e29b-41d4-a716-446655440000",
                key="dGVzdF9rZXlfZGF0YQ==",  # base64 encoded "test_key_data"
                key_size=256,
            )

            # Mock authorization check to return True
            with patch.object(key_service, "_verify_key_access", return_value=True):
                # Test key retrieval
                result = await key_service.get_keys_by_ids(
                    master_sae_id="MASTER001",
                    key_ids=key_ids,
                    requesting_sae_id="SLAVE001",
                )

                assert result is not None
                assert hasattr(result, "keys")

    @pytest.mark.asyncio
    async def test_key_pool_status_integration(self, key_service):
        """Test key pool status integration"""
        # Mock pool status to avoid database dependency
        with patch.object(
            key_service.key_pool_service, "get_pool_status"
        ) as mock_status:
            mock_status.return_value = {
                "active_keys": 1000,
                "total_capacity": 10000,
                "utilization_percentage": 10.0,
                "last_updated": datetime.datetime.utcnow().isoformat(),
            }

            # Mock health metrics
            with patch.object(
                key_service.key_pool_service, "get_pool_health_metrics"
            ) as mock_health:
                mock_health.return_value = {
                    "health_status": "healthy",
                    "availability_ratio": 0.8,
                }

                # Mock cleanup statistics
                with patch.object(
                    key_service.key_storage_service, "get_key_cleanup_statistics"
                ) as mock_cleanup:
                    mock_cleanup.return_value = {
                        "total_keys": 1000,
                        "expired_keys": 50,
                        "active_keys": 950,
                    }

                    # Mock alert conditions
                    with patch.object(
                        key_service.key_pool_service, "check_alert_conditions"
                    ) as mock_alerts:
                        mock_alerts.return_value = []

                        # Test pool status retrieval
                        status = await key_service.get_key_pool_status()

                        assert status is not None
                        assert "pool_status" in status
                        assert "health_metrics" in status
                        assert "cleanup_statistics" in status
                        assert "active_alerts" in status

    @pytest.mark.asyncio
    async def test_key_management_optimization(self, key_service):
        """Test key management optimization"""
        # Mock pool optimization
        with patch.object(
            key_service.key_pool_service, "optimize_pool_performance"
        ) as mock_optimize:
            mock_optimize.return_value = {
                "optimizations_applied": 2,
                "performance_improvement": "15%",
            }

            # Mock cleanup scheduling
            with patch.object(
                key_service.key_storage_service, "schedule_key_cleanup"
            ) as mock_cleanup:
                mock_cleanup.return_value = True

                # Mock health metrics
                with patch.object(
                    key_service.key_pool_service, "get_pool_health_metrics"
                ) as mock_health:
                    mock_health.return_value = {
                        "health_status": "healthy",
                        "recommendations": ["Test recommendation"],
                    }

                    # Test optimization
                    optimization = await key_service.optimize_key_management()

                    assert optimization is not None
                    assert "pool_optimization" in optimization
                    assert "cleanup_scheduled" in optimization
                    assert "recommendations" in optimization

    @pytest.mark.asyncio
    async def test_monitoring_setup(self, key_service):
        """Test monitoring setup"""
        # Test monitoring configuration
        alert_thresholds = {
            "key_exhaustion": 100,
            "performance_degradation": 0.8,
            "error_rate": 0.05,
        }

        success = await key_service.setup_key_management_monitoring(alert_thresholds)
        assert success is True


if __name__ == "__main__":
    pytest.main([__file__])
